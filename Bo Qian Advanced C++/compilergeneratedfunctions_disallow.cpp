/*compiler writes 4 functions if they are not explicity declared,but are used in the program. they are public.
1. Copy Constructor
2. Copy Assignment Operator (=) by operator overloading.
3. Destructor
4. Default Constructor(only if no constructor(parameterised or not) declared at all)
Eg: copy constructor won't be generated if you dont use it in your program at all.
if compiler generated functions are unable to do their job,then they wont be generated at all by the compiler.
Eg; if base class destructor is private and can't be called by derived class,then default destructor wont be generated by compiler
Eg; if base class does not have default constructor,then derived class default constructor wont be generated automatically by the compiler.
Eg: if an object of a class is CONST or REFERENCE,w.k.t such members can't be copied,they can only be initialised. therefore the copy assignment operator will not be generated. 
BUT COPY CONSTRUCTOR WILL STILL BE GENERATED AND z WILL BE INITIALISED USING INITIALIZER LIST.*/
#include<iostream>
using namespace std;
class Shithead
{
    string name;
    public:
        Shithead(string s="tejas") //this is also default constructor because an object can be declared without any parameters. this is because we have set a default
        //value of the string s
        {name=s;}
};
class Yapral
{
    Yapral(const Yapral &p2)=delete;//if you want to disallow the copy constructor from being used. or just make it private and dont define it,just declare with empty body.
    string name;
    public:
    Yapral(string s)
    {name=s;}
};
class Tejas
{
    Yapral nigga;
    string &ab;
};
class Point
{
    private:
        int x,y;
        const int z; //default constructor is made even though const is present. default constructor se initialise karne ki zarurat nahi hai.
    public:
        Point():z(71)
        {

        }
        Point(int x1,int y1,int z1):z(z1)
        {x=x1;y=y1;}
        int getx(){return x;}
        int gety(){return y;};
        int getz(){return z;}
};

int main()
{
    /*Tejas tejas12; will give error. because compiler will try to create default constructor. compiler generated default constructor will call the data member's default
    constructor. therefore,it'll try to construct nigga. but Yapral does not have default constructor. and it can't be generated too because its constructor already
    exists. therefore,nigga cant be constructed. so,even tejas12 cant be constructed because default constructor of Tejas doesn't exist.
    even if you do make a default constructor,it still won't compile because Tejas has a string reference which hasnt been initialised.
    and the default constructor can't initialise the reference member. so BT hogi*/
    Yapral y1("lmao");
    //Yapral y2(y1); wont work
    Point p1;
    Point p2(p1); //default copy constructor which is generated even though z is const 
    cout<<p2.getz()<<endl;
    cout<<p1.getx()<<" "<<p1.gety()<<endl;
    cout<<p2.getx()<<" "<<p2.gety()<<endl;
    Point p3;
    //p3=p1; //assignment operator. won't work because copy constructor is not generated because of const z. explicitly declare karna padega tumhe
    //both the copy constructor and the assignment operator are used for the same purpose i.e to initialise one object to another object.
    cout<<p3.getx()<<" "<<p3.gety();
}